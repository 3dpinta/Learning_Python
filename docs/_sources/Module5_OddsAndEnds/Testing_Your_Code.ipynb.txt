{
 "cells": [
  {
   "cell_type": "raw",
   "metadata": {
    "raw_mimetype": "text/restructuredtext"
   },
   "source": [
    ".. meta::\n",
    "   :description: Topic: Writing tests for your code, Difficulty: Medium, Category: Section\n",
    "   :keywords: test, pytest, automated, unit, integration, property-based, hypothesis  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Testing Your Code\n",
    "\n",
    "This section will introduce us to the critically-important and often-overlooked process of testing code. \n",
    "We will begin by considering some driving motivations for writing tests.\n",
    "Next, we will study the basic anatomy of a test-function, including the `assert` statement, which serves as the nucleus of our test functions.\n",
    "Armed with the ability to write a rudimentary test, we will welcome, with open arms, the powerful testing framework [pytest](https://docs.pytest.org/).\n",
    "This will inform how we structure our tests alongside our Python project that we are developing; with pytest, we can incisively run our tests with the press of a single button.\n",
    "Furthermore, it will allow us to greatly streamline and even begin to automate some of our tests.\n",
    "Finally, we will take a step back to consider some strategies for writing effective tests.\n",
    "Among these is a methodology that is near and dear to my heart: property-based testing.\n",
    "This will take us down a bit of a rabbit hole, where we will find the powerful property-based testing library [Hypothesis](https://hypothesis.readthedocs.io/) waiting to greet us (adorned with the mad Hatter's cap and all).\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Why Should We Write Tests?\n",
    "With great power comes great responsibility: tests help us be responsible for the code that we create and that others will (hopefully) use.\n",
    "\n",
    "The fact of the matter is that everyone already tests their code to some extent.\n",
    "After coding, say, a new function, it is only natural to contrive an input to feed it, and to check that it returns the output that you expected.\n",
    "To the extent that anyone would want to see evidence that their code works, we need not motivate the importance of testing.\n",
    "\n",
    "Less obvious is the massive benefits that we stand to gain from formalizing this testing process.\n",
    "And by \"formalizing\", we mean taking the test scenarios that we were running our code through, and encapsulating them in their own functions that can be run from end-to-end.\n",
    "We will accumulate these functions into a \"test suite\" that we can run quickly and repeatedly.\n",
    "\n",
    "There are plenty of practical details ahead for us to learn, so let's expedite this discussion and simply list some of the benefits that we can expect to reap from writing a robust test suite:\n",
    "\n",
    "- It saves us lots of time:\n",
    "  > After you have devised a test scenario for your code, it may only take us a second or so to run it - perhaps we need only run a couple of Jupyter notebook cells to check the output.\n",
    "  > However, this will quickly become unwieldy as we write more code and devise more test scenarios.\n",
    "  > Soon we will be dissuaded from running our tests except for on rare occasions.\n",
    "  > With a proper test suite, we can run all of our test scenarios with the push of a button, and a series of green check-marks (or red x's...) will summarize the health of our project (insofar as our tests serve as good diagnostics).\n",
    "  > This, of course, also means that we will find and fix bugs much faster!\n",
    "  > In the long run, our test suite will afford us the ability to aggressively exercise (and exorcise) our code at little cost.\n",
    "- It increases the \"shelf life\" of our code:\n",
    "  > If you've ever dusted off a project that you haven't used for years (or perhaps only months or weeks...), you might know the tribulations of getting old code to work.\n",
    "  > Perhaps, in the interim, new versions of our project's dependencies, like PyTorch or Matplotlib, were released and have incompatibilities with our project's code.\n",
    "  > And perhaps _we can't even remember_ all of the ways in which our project is supposed to work.\n",
    "  > Our test suite provides us with a simple and incisive way to dive back into our work.\n",
    "  > It will point us to any potential incompatibilities that have accumulated over time.\n",
    "  > It also provides us with a large collection of detailed use-cases of our code;\n",
    "  > we can read through our tests remind ourselves of the inner-workings of our project.\n",
    "- It will inform the design and usability of our project for the better:\n",
    "  > Although it may not be obvious from the outset, writing testable code leads to writing better code.\n",
    "  > This is, in part, because the process of writing tests gives us the opportunity to actually _use_ our code under varied circumstances.\n",
    "  > The process of writing tests will help us suss out cumbersome function interfaces, brittle statefulness, and redundant capabilities in our code. If _we_ find it frustrating to use our code within our tests, then surely others will find it frustrating to use in applied settings.\n",
    "- It makes it easier for others to contribute to a project:\n",
    "  > Having a healthy test suite lowers the barrier to entry for a project. \n",
    "  > A contributor can make improvements to the project and quickly check to see if they have broken it or changed any of its behavior.\n",
    "\n",
    "This all sounds great, but where do we even start the process writing a test suite? \n",
    "Let's begin by seeing what constitutes a basic test function."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "## The Basic Anatomy of a Test Function\n",
    "Let's write a function that tests the following `count_values` code:\n",
    "\n",
    "```python\n",
    "# Defining a function that we will be testing\n",
    "\n",
    "def count_vowels(x: str, include_y: bool = False) -> int:\n",
    "    \"\"\"Returns the number of vowels contained in `x`.\n",
    "    \n",
    "    The vowel 'y' is included optionally.\n",
    "\n",
    "    Examples\n",
    "    --------\n",
    "    >>> count_vowels(\"happy\")\n",
    "    1\n",
    "    >>> count_vowels(\"happy\", include_y=True)\n",
    "    2\n",
    "    \"\"\"\n",
    "    vowels = set(\"aeiouAEIOU\")\n",
    "    if include_y:\n",
    "        vowels.update(\"yY\")\n",
    "    return sum(1 for char in x if char in vowels)\n",
    "```\n",
    "\n",
    "(Note that we will be making use of [type hinting](https://www.pythonlikeyoumeanit.com/Module5_OddsAndEnds/Writing_Good_Code.html#Type-Hinting) to help document the interfaces of our functions.\n",
    "You may want to briefly review the linked material if this is unfamiliar to you)\n",
    "\n",
    "For our most basic test, we can simply call `count_values` under various contrived inputs and *assert* that it returns the expected output.\n",
    "The desired behavior for this test function, upon being run, is to:\n",
    "\n",
    "- Raise an error if any of our assertions *failed* to hold true.\n",
    "- Complete \"silently\" if all of our assertions hold true (i.e. our test function will simply [return None](https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Functions.html#The-return-Statement))\n",
    "\n",
    "Here, we will be making use of Python's `assert` statements, whose behavior will be easy to deduce from the context of this test alone; we will be formally introduced to them soon.\n",
    "\n",
    "```python\n",
    "# Writing a test function for `count_vowels`\n",
    "\n",
    "def test_count_vowels_basic():\n",
    "    assert count_vowels(\"aA bB yY\", include_y=False) == 2\n",
    "    assert count_vowels(\"aA bB yY\", include_y=True) == 4\n",
    "```\n",
    "\n",
    "To run this test, we simply call the function:\n",
    "\n",
    "```python\n",
    "# running our test function\n",
    ">>> test_count_vowels_basic()  # passes: returns None | fails: raises error\n",
    "```\n",
    "\n",
    "As described above, the fact our function runs and simply returns `None` means that our code has passed this test. We've written and run our very first test! It certainly isn't the most robust test, but it is a good start.\n",
    "\n",
    "Let's look more carefully at the structure of `test_count_vowels_basic`.\n",
    "Note that this function doesn't take in any inputs;\n",
    "thanks to [Python's scoping rules](https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Scope.html), we can reference our `count_vowels` function within our test as long as it is defined in the same \"namespace\" as `test_count_vowels_basic`.\n",
    "That is, we can either define `count_vowels` in the same .py file (or Jupyter notebook, if you are following along with this material in a notebook) as `test_count_vowels_basic`, or we can [import](https://www.pythonlikeyoumeanit.com/Module5_OddsAndEnds/Modules_and_Packages.html#Import-Statements) `count_vowels` from wherever it is defined, and into the file containing our test.\n",
    "The latter scenario is by far the most common one in practice. \n",
    "More on this later.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\"> \n",
    "\n",
    "**Reading Comprehension: The Basic Anatomy of a Test**\n",
    "\n",
    "Add an additional assertion to the body of `test_count_vowels_basic`, which tests whether `count_vowels` handles the empty-string (`\"\"`) case appropriately.\n",
    "Make sure to run your updated test to see if it passes.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Testing Our Tests\n",
    "\n",
    "It is surprisingly easy to unwittingly write a test that always passes or that fails to test our code as we had intended.\n",
    "This is a particularly treacherous mistake to make as it leads us to falsely believe that our function is working as-expected.\n",
    "**Thus a critical step in the test-writing process is to intentionally mutate the function of interest - to corrupt its behavior in such a way that our test ought to raise an error.**\n",
    "Once we confirm that our test does indeed raise an error as-expected, we restore the function to its original form and re-run the test and see that it passes. \n",
    "\n",
    "We ought to mutate our function in a way that is trivial to undo; we can use of code-comments towards this end.\n",
    "All [IDEs](https://www.pythonlikeyoumeanit.com/Module1_GettingStartedWithPython/Getting_Started_With_IDEs_and_Notebooks.html) have the ability to \"block-comment\" selected code.\n",
    "In a Jupyter notebook code cell, we can highlight multiple lines of code and press `CTRL + /`: this will comment-out these lines of code.\n",
    "The same key-combination will also un-comment a highlighted block of commented code.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\"> \n",
    "\n",
    "**Reading Comprehension: Testing Your Test via Manual Mutation**\n",
    "\n",
    "Temporarily change the body of `count_vowels` such that the second assertion in `test_count_vowels_basic` raises an error.\n",
    "Run the test to confirm that the second assertion raises,\n",
    "and then restore `count_vowels` to its original form.\n",
    "Finally, rerun the test to see that `count_vowels` once again passes all of the assertions.\n",
    "\n",
    "</div>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With our first test function under our belt, it is time for us to clearly understand how `assert` statements work and how they should be used. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "lines_to_next_cell": 0
   },
   "source": [
    "### Assert Statements\n",
    "Similar to `return`, `def`, or `if`, the term `assert` is a reserved term in the Python language. \n",
    "It has the following specialized behavior:\n",
    "\n",
    "```python\n",
    "# demonstrating the rudimentary behavior of the `assert` statement\n",
    "\n",
    "# asserting an expression whose boolean-value is `True` will complete \"silently\"\n",
    ">>> assert 1 < 2\n",
    "\n",
    "# asserting an expression whose boolean-value is `False` raises an error\n",
    ">>> assert 2 < 1\n",
    "---------------------------------------------------------------------------\n",
    "AssertionError                            Traceback (most recent call last)\n",
    "<ipython-input-5-c82711d5fe4d> in <module>\n",
    "----> 1 assert 2 < 1\n",
    "\n",
    "AssertionError: \n",
    "\n",
    "# we can include an error message with our assertion\n",
    ">>> assert 0 in [1, 2, 3], \"0 is not in the list\"\n",
    "---------------------------------------------------------------------------\n",
    "AssertionError                            Traceback (most recent call last)\n",
    "<ipython-input-8-e72fb36dc785> in <module>\n",
    "----> 1 assert 0 in [1, 2, 3], \"0 is not in the list\"\n",
    "\n",
    "AssertionError: 0 is not in the list\n",
    "```\n",
    "\n",
    "The general form of an assertion statement is:\n",
    "\n",
    "```python\n",
    "assert <expression> [, <error-message>] \n",
    "```\n",
    "\n",
    "When an assertion statement is executed, the built-in `bool` function is called on the object that is returned by `<expression>`; if `bool(<expression>)` returns `False`, then an `AssertionError` is raised.\n",
    "If you included a string in the assertion statement - separated from `<expression>` by a comma - then this string will be printed as the error message.\n",
    "\n",
    "See that the assertion statement: \n",
    "```python\n",
    "assert expression, error_message\n",
    "```\n",
    "\n",
    "is effectively shorthand for the following code:\n",
    "\n",
    "```python\n",
    "# long-form equivalent of: `assert expression, error_message`\n",
    "if bool(expression) is False:\n",
    "    raise AssertionError(error_message)\n",
    "```\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\"> \n",
    "\n",
    "**Reading Comprehension: Assertions**\n",
    "\n",
    "Given the following objects:\n",
    "\n",
    "```python\n",
    "a_list = []\n",
    "a_number = 22\n",
    "a_string = \"abcdef\"\n",
    "```\n",
    "\n",
    "Write two assertion statements, each one with the corresponding behavior:\n",
    "\n",
    "- asserts that `a_list` is _not_ empty\n",
    "- asserts that the number of vowels in `a_string` is less than `a_number`; include and error message that prints the actual number of vowels\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### What is the Purpose of an Assertion?\n",
    "In our code, an assertion should be used as _a statement that is true unless there is a bug our code_.\n",
    "It is plain to see that the assertions in `test_count_vowels_basic` fit this description.\n",
    "However, it can also be useful to include assertions within our source code itself.\n",
    "For instance, we know that `count_vowels` should always return a non-negative integer for the vowel-count, and that it is illogical for this count to exceed the number of characters in the input string.\n",
    "We can explicitly assert that this is the case:\n",
    "\n",
    "```python\n",
    "# an example of including an assertion within our source code\n",
    "\n",
    "def count_vowels(x: str, include_y: bool = False) -> int:\n",
    "    vowels = set(\"aeiouAEIOU\")\n",
    "    if include_y:\n",
    "        vowels.update(\"yY\")\n",
    "    count = sum(1 for char in x if char in vowels)\n",
    "    \n",
    "    # This assertion should always be true: it is asserting that \n",
    "    # the internal logic of our function is correct\n",
    "    assert isinstance(count, int) and 0 <= count <= len(x)\n",
    "    return count\n",
    "```\n",
    "\n",
    "Note that this assertion *is not meant to check if the user passed bad inputs for* `x` *and* `include_y`.\n",
    "Rather, it is meant to assert that our own internal logic holds true.\n",
    "\n",
    "Admittedly, the `count_vowels` function is simple enough that the inclusion of this assertion is rather pedantic.\n",
    "That being said, as we write increasingly sophisticated code, we will find that this sort of assertion will help us catch bad internal logic and oversights within our code base."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Links to Official Documentation\n",
    "\n",
    "- [The assert statement](https://docs.python.org/3/reference/simple_stmts.html?highlight=assert#the-assert-statement)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Reading Comprehension Solutions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**The Basic Anatomy of a Test: Solution**\n",
    "\n",
    "Add an additional assertion to the body of `test_count_vowels_basic`, which tests whether `count_vowels` handles the empty-string (`\"\"`) case appropriately.\n",
    "Make sure to run your updated test to see if it passes.\n",
    "\n",
    "```python\n",
    "def test_count_vowels_basic():\n",
    "    assert count_vowels(\"aA bB yY\", include_y=False) == 2\n",
    "    assert count_vowels(\"aA bB yY\", include_y=True) == 4\n",
    "    assert count_vowels(\"\", include_y=True) == 0\n",
    "```\n",
    "\n",
    "```python\n",
    "# running the test in a notebook-cell: the function should simply return\n",
    "# `None` if all assertions hold true\n",
    ">>> test_count_vowels_basic()\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Testing Your Test via Manual Mutation: Solution**\n",
    "\n",
    "Temporarily change the body of `count_vowels` such that the _second_ assertion in `test_count_vowels_basic` raises an error.\n",
    "> Let's comment out the `if include_y` block in our code - this should prevent us from counting y's, and thus should violate the second assertion in our test.\n",
    "\n",
    "```python\n",
    "# Breaking the behavior of `include_y=True`\n",
    "def count_vowels(x: str, include_y: bool = False) -> int:\n",
    "    vowels = set(\"aeiouAEIOU\")\n",
    "    # if include_y:\n",
    "    #    vowels.update(\"yY\")\n",
    "    return sum(1 for char in x if char in vowels)\n",
    "```\n",
    "\n",
    "```python\n",
    "# the second assertion should raise an error\n",
    ">>> test_count_vowels_basic()\n",
    "---------------------------------------------------------------------------\n",
    "AssertionError                            Traceback (most recent call last)\n",
    "<ipython-input-5-32301ff829e9> in <module>\n",
    "----> 1 test_count_vowels_basic()\n",
    "\n",
    "<ipython-input-4-99ef0ca3d859> in test_count_vowels_basic()\n",
    "      1 def test_count_vowels_basic():\n",
    "      2     assert count_vowels(\"aA bB yY\", include_y=False) == 2\n",
    "----> 3     assert count_vowels(\"aA bB yY\", include_y=True) == 4\n",
    "\n",
    "AssertionError: \n",
    "```\n",
    "\n",
    "> Great! That assertion really does help to ensure that we are counting y's correctly.\n",
    "\n",
    "Restore `count_vowels` to its original form and rerun the test to see that `count_vowels` once again passes all of the assertions.\n",
    "\n",
    "```python\n",
    "# Restore the behavior of `include_y=True`\n",
    "def count_vowels(x: str, include_y: bool = False) -> int:\n",
    "    vowels = set(\"aeiouAEIOU\")\n",
    "    if include_y:\n",
    "        vowels.update(\"yY\")\n",
    "    return sum(1 for char in x if char in vowels)\n",
    "```\n",
    "\n",
    "```python\n",
    "# confirming that we restored the proper behavior in `count_vowels`\n",
    ">>> test_count_vowels_basic()\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Assertions: Solution**\n",
    "```python\n",
    "a_list = []\n",
    "a_number = 22\n",
    "a_string = \"abcdef\"\n",
    "```\n",
    "\n",
    "Assert that `a_list` is _not_ empty:\n",
    "\n",
    "```python\n",
    ">>> assert a_list\n",
    "---------------------------------------------------------------------------\n",
    "AssertionError                            Traceback (most recent call last)\n",
    "<ipython-input-10-2eba8294859e> in <module>\n",
    "----> 1 assert a_list\n",
    "\n",
    "AssertionError: \n",
    "```\n",
    "\n",
    "> You may have written `assert len(a_list) > 0` - this is also correct.\n",
    "> However, recall that calling `bool` on any sequence (list, tuple, string, etc.) will return `False` if the sequence is empty.\n",
    "> This is a reminder that an assertion statement need not include an explicit logical statement, such as an inequality - that `bool` will be called on whatever the provided expression is.\n",
    "\n",
    "Assert that the number of vowels in `a_string` is fewer than `a_number`; include and error message that prints the actual number of vowels:\n",
    "\n",
    "```python\n",
    ">>> assert count_vowels(a_string) < a_number, f\"Number of vowels, {count_vowels(a_string)}, exceeds {a_number}\"\n",
    "```\n",
    "\n",
    "> Note that we make use of an [f-string](https://www.pythonlikeyoumeanit.com/Module2_EssentialsOfPython/Basic_Objects.html#Formatting-strings) as a convenient means for writing an informative error message."
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "formats": "ipynb,md"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
