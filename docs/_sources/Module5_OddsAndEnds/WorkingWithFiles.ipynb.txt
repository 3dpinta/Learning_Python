{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Working with Files\n",
    "This section will discuss the best practices for writing Python code that involves reading from and writing to files. We will learn about the built-in `pathlib.Path` object, which will help to ensure that the code that we write is portable across operating systems (OS) (i.e. Windows vs MacOS vs Linux). We will also be introduced to a so-called context manager, which will permit us to read-from and write-to a file safely; by \"safely\" we mean that we will be assured that any file that we open will eventually be closed properly, so that it will not be corrupted even in the event that our code hits an error."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Working with Paths\n",
    "Suppose you are writing a Jupyter notebook where you are analyzing data that is saved to your computer. You will naturally need to detail the location where your data is stored on your computer's file system so that you can load your data. Let's suppose that this notebook is in the directory `my_folder` and that there is a directory, `data`, within it, which contains some text files with your data. Thus your directory structure looks like this:\n",
    "\n",
    "```\n",
    "my_folder/\n",
    "  |-notebook.ipynb\n",
    "  |-data/\n",
    "     |-data1.txt\n",
    "     |-data2.txt\n",
    "```\n",
    "Now, if you are on a machine that is running Linux or MacOS, the path to `data1.txt` relative to the notebook is: `./data/data1.txt`. See that the character `/` is used as a separator used to denote subsequent directories in a path. On a Windows machine, the separator is `\\`, thus the path to your data would be written as `.\\data\\data1.txt`. We want to write our code so that it can be utilized, without modification, across operating systems. This where Python's fantastic `pathlib` module comes in handy.\n",
    "\n",
    "### pathlib.Path\n",
    "\n",
    "The built-in [pathlib module](https://docs.python.org/3/library/pathlib.html) provides a number of classes that make it easy to work with file system paths across operating systems. We will limit our discussion to the `pathlib.Path` class, which will take care of all of our most pressing needs. This class allows us to write all of our path-related code in a single way, and it will convert the path to the operating system-appropriate format for us underneath the hood.\n",
    "\n",
    "Let's begin by creating a `Path` object that points to the directory containing the present notebook:\n",
    "\n",
    "```python\n",
    "# creating a path-object pointing to the present directory\n",
    ">>> from pathlib import Path\n",
    ">>> root = Path(\".\") # '.' means: the present directory that this code exists in\n",
    "```\n",
    "\n",
    "Because I am running this code from a Windows machine, this will form a `WindowsPath` object automatically:\n",
    "\n",
    "```python\n",
    ">>> root\n",
    "WindowsPath('.')\n",
    "```\n",
    "\n",
    "If I were running on a Linux or MacOS machine, it would have formed a `PosixPath` object instead. Fortunately, we need not worry about these details as these classes handle them for us! The `Path` class has many useful methods for us to leverage. First, see that it conveniently overrides the `/` operator (by implementing a [special method](http://www.pythonlikeyoumeanit.com/Module4_OOP/Special_Methods.html)) so that we can create a path to a subsequent directory. Let's see this in action:\n",
    "\n",
    "```python\n",
    "# creating a path to a file in a subdirectory\n",
    ">>> path_to_data1 = root / \"data\" / \"data1.txt\"\n",
    ">>> path_to_data1\n",
    "WindowsPath('data/data1.txt')\n",
    "```\n",
    "See that the `/` operator, when used in conjunction with a `Path` instance, created a new path with the appropriate path-separator for the present OS. This is extremely convenient! \n",
    "\n",
    "Let's proceed to explore some other useful methods that `Path` provides us with. These methods enable us to inspect directories and files, create new directories, list all of the files in a directory, open files to for reading/writing, and much more. A complete listing of these methods can be found [here](https://docs.python.org/3/library/pathlib.html#methods-and-properties) and [here](https://docs.python.org/3/library/pathlib.html#methods), collectively; it is highly recommended that you take time to look through them.\n",
    "\n",
    "\n",
    "```python\n",
    ">>> root = Path(\".\")\n",
    ">>> path_to_data1 = root / \"data\" / \"data1.txt\"\n",
    "\n",
    "# Checking to see if a file or directory exists:\n",
    ">>> path_to_data1.exists()\n",
    "True\n",
    "\n",
    ">>> (root / \"bogus_path\").exists()\n",
    "False\n",
    "\n",
    "# Getting the \"absolute\" path to a file or directory:\n",
    ">>> path_to_data1.absolute()\n",
    "WindowsPath('C:/Users/TerranceWasabi/Desktop/PLYMI/Module5_OddsAndEnds/data/data1.txt')\n",
    "\n",
    "# Access the name of the file that the path is pointing to\n",
    ">>> path_to_data1.name\n",
    "'data1.txt'\n",
    "\n",
    "# Create a new directory within the present directory\n",
    ">>> root.mkdir(\"new_folder\")\n",
    "\n",
    "# Use 'glob' to return a generator over all files\n",
    "# that match a specified pattern. E.g. get path to every\n",
    "# .txt file in a directory\n",
    ">>> list((root / \"data\").glob(\"*.txt\"))\n",
    "[WindowsPath('data/data1.txt'), WindowsPath('data/data2.txt')]\n",
    "\n",
    "# convert a path-object to a string formatted for the present OS\n",
    ">>> str(path_to_data1)\n",
    "'data\\\\data1.txt'\n",
    "```\n",
    "\n",
    "\n",
    "\n",
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Takeaway**: \n",
    "\n",
    "You should strive to utilize `pathlib.Path` whenever you are working with file system paths in your code. To reiterate - this will ensure that your code is portable across operating systems, it will help make your path handling easy to read, plus this class's methods provides a massive amount of functionality for you to leverage at your convenience.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Note**: \n",
    "\n",
    "`pathlib` was introduced in Python 3.4. Although many 3rd party libraries have updated their file-I/O utilities to accept both strings and `pathlib.Path` objects (e.g. `numpy.save` can be passed a `Path` instance to tell it where to save a numpy-array), some libraries are late to the party and will only accept strings as paths. On such occasions you can simple convert your `Path` instance to a string by calling `str` on it, and then pass the resulting string-path to the file-I/O function. This is also a friendly reminder to accomodate `pathlib.Path` objects whenever you find yourself writing your own file-I/O functions!\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Opening Files\n",
    "It is recommended that you refer to the [official Python tutorial](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files) for a simple rundown of file reading and writing\n",
    "\n",
    "Whenever you instruct your code to open a file for reading or writing, you must take care that the file ultimately is closed so that its data is not vulnerable to being modified. Python provides the `open` context manager, which is designed to ensure that a file will be closed even in the event that our code raises an error.\n",
    "\n",
    "The following code opens the file \"file1.txt\" for writing:\n",
    "\n",
    "```python\n",
    "# demonstrating the use of the `open` context manager\n",
    "\n",
    "path_to_file = Path(\".\") / \"file1.txt\"\n",
    "with open(path_to_file, mode=\"w\") as f:\n",
    "    # The indented space enters the \"context\" of the open file.\n",
    "    # Leaving the indented space exist the context of the opened file, forcing\n",
    "    # the file to be closed. This is ensured even if our code causes an error\n",
    "    # within this indented block\n",
    "    f.write('this is a line.\\nThis is a second line.\\nThis is the third line.')\n",
    "\n",
    "# The file is closed here.\n",
    "```\n",
    "\n",
    "The syntax `with <context_manager>() as <context_variable>:` signifies the creation of a context with the object `<context_variable>` . In this case `open` is the context manager, and the variable we named `f` is the file-object that is opened within that context, which is delimited by the subsequent indented space. You can also call `open` directly from a `Path` instance:\n",
    "\n",
    "```python\n",
    "with path_to_file.open(mode=\"w\") as f:\n",
    "    f.write('this is a line.\\nThis is a second line.\\nThis is the third line.')\n",
    "```\n",
    "\n",
    "\n",
    "The complete documentation for `open` can be found [here](https://docs.python.org/3/library/functions.html#open).\n",
    "\n",
    "### Specifying the Open-Mode\n",
    "Specifying `mode='w'` indicates that we will be writing to the file anew - if the file already has any content, that content will be *erased* before being written to. The following are the available \"modes\" for opening a file:\n",
    "\n",
    "|Mode| Explanation |\n",
    "|---|---|\n",
    "|`r`| Open the file for reading text|\n",
    "|`w`| Open the file, **clearing its contents**, for writing text anew |\n",
    "|`a`| Open the file to write text to end of any existing content, thus \"appending\" to the file |\n",
    "|`x`| Open the file for writing text, failing if the file already exists |\n",
    "|`+`| Open the file for both reading and writing text |\n",
    "\n",
    "By default, these modes will read and write text utilizing the unicode (utf-8) decoding/encoding specification. That is, when you read data from your file system with `mode='r'` Python will automatically *decode* that binary data that was stored on your machine according to utf-8, which converts the binary data to written text stored as a string. Similarly, writing a string to a file in modes 'w', 'a', 'x', or '+' will presume that the string should be encoded into a binary representation (which is necessary for it to be stored as a file) according to the utf-8 encoding scheme.\n",
    "\n",
    "You can instead force Python to read and write strictly in terms of binary data by adding a `'b'` to these modes: `'rb'`, `'wb'`, `'ab'`, `'xb'`, `'+b'`. It is important to be aware of this binary mode. For example, if you are saving a NumPy-array, you should open a file in the 'wb' or 'xb' modes so that it expects binary data to be written to it; obviously we are not saving text when we are saving a NumPy array of numbers.\n",
    "\n",
    "```python\n",
    "# saving a NumPy-array to the file 'array.npy'\n",
    ">>> import numpy as np\n",
    ">>> x = np.array([1, 2, 3])\n",
    "\n",
    "# file must be open for binary-write mode\n",
    "# since we are not saving text\n",
    ">>> with open(\"array.npy\", mode=\"wb\") as f:\n",
    "...     np.save(f, x)\n",
    "\n",
    "```\n",
    "\n",
    "### Working with the File Object\n",
    "When we invoke `open` to open a file, we gain access to an opened file object. The methods of this file object allow us to write-to and read-from the opened file (assuming that we have utilized the appropriate mode when opening it).\n",
    "\n",
    "```python\n",
    "# demonstrating the `read` method of the file object\n",
    ">>> with open(path_to_file, mode=\"r\") as var:\n",
    "...     # reads the entire content of the file as a string\n",
    "...     content = var.read() \n",
    "\n",
    ">>> content\n",
    "'this is a line.\\nThis is a second line.\\nThis is the third line.'\n",
    ">>> print(content)\n",
    "this is a line.\n",
    "This is a second line.\n",
    "This is the third line.\n",
    "```\n",
    "\n",
    "The following summarizes some of the methods available to this file object:\n",
    "\n",
    "- `read()`: Read the entire content of the file as a string or as bytes (depending on the open-mode)\n",
    "- `readline()`: Read the next line of text from the file, including the trailing `'\\n'` character\n",
    "- `readlines()`: Read in the lines of text from the file, storing each line as an string in a list.\n",
    "- `write(x)`: Write `x` (a string) to the file.\n",
    "- `writelines(x)`: Given an iterable of strings, treat each string as a line of text to be written to the file (the inverse of `readlines`)\n",
    "\n",
    "Also, it is important to note that the file object can be *iterated over*, and that each iteration will return an individual line of text from the file. This is the best way to read through an entire file line-by-line."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example: Writing and Reading a Text File\n",
    "\n",
    "Given the following string:\n",
    "\n",
    "```python\n",
    ">>> some_text = \"\"\"A bagel rolled down the hill.\n",
    "I mean *all* the way down the hill.\n",
    "A lady watched it roll.\n",
    "Way to help me out.\"\"\"\n",
    "\n",
    ">>> some_text\n",
    "'A bagel rolled down the hill.\\nI mean *all* the way down the hill.\\nA lady watched it roll.\\nWay to help me out.'\n",
    "```\n",
    "\n",
    "Write that string to a file, \"a_poem.txt\":\n",
    "\n",
    "```python\n",
    "# use mode-x to ensure that we don't overwrite the file\n",
    "# if it already exists\n",
    "with open(\"a_poem.txt\", mode=\"x\") as my_open_file:\n",
    "    my_open_file.write(some_text)\n",
    "```\n",
    "\n",
    "Now read in each line of the file and append that line to the list `out`, but *only if that line starts with the letter 'A'*:\n",
    "\n",
    "```python\n",
    "with open(\"a_poem.txt\", mode=\"r\") as my_open_file:\n",
    "    # recall: iterating over the file-object yields each line of the file\n",
    "    # one line at a time\n",
    "    out = [line for line in my_open_file if line.startswith(\"A\")]\n",
    "```\n",
    "\n",
    "```python\n",
    "# verify that the output is what we expect\n",
    ">>> out\n",
    "['A bagel rolled down the hill.\\n', 'A lady watched it roll.\\n']\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example: Writing and Reading NumPy Arrays\n",
    "First, note that NumPy's standard binary file type, used to store array data, is known as '.npy' file. The NumPy binary archive format, which stores multiple arrays in one file, is known as the '.npz' format.\n",
    "\n",
    "Let's save the array `x = np.array([1, 2, 3])` to the binary file (not a text file) \"my_array.npz\".\n",
    "\n",
    "```python\n",
    "import numpy as np\n",
    "x = np.array([1, 2, 3])\n",
    "\n",
    "# we aren't saving text thus we must open \n",
    "# our file in binary-write mode\n",
    "with open(\"my_array.npy\", mode=\"wb\") as f:\n",
    "     np.save(f, x)\n",
    "```\n",
    "\n",
    "Now let's load this array from the binary file:\n",
    "\n",
    "```python\n",
    "# once again, the file must be opened to read\n",
    "# binary data, not text data\n",
    "with open(\"my_array.npy\", mode=\"rb\") as f:\n",
    "     y = np.load(f)\n",
    "```\n",
    "```python\n",
    ">>> y\n",
    "array([1, 2, 3])\n",
    "```\n",
    "\n",
    "Finally, let's save multiple arrays to a single archive file \"my_archive.npz\".\n",
    "\n",
    "```python\n",
    "a0 = np.array([1, 2, 3])\n",
    "a1 = np.array([4, 5, 6])\n",
    "a2 = np.array([7, 8, 9])\n",
    "\n",
    "with open(\"my_archive.npz\", mode=\"wb\") as my_archive_file:\n",
    "    # you can use keyword arguments to specify the names used\n",
    "    # to store the array in the archive\n",
    "    np.savez(my_archive_file, array_0=a0, array_1=a1, array_2=a2)\n",
    "```\n",
    "\n",
    "`np.load` can be used as a context manager in lieu of `open`. The file-object that it produces is our archive of numpy arrays, and it provides a dictionary-like interface for accessing these arrays:\n",
    "\n",
    "```python\n",
    "with np.load(\"my_archive.npz\") as my_archive_file:\n",
    "    out0 = my_archive_file[\"array_0\"]\n",
    "    out1 = my_archive_file[\"array_1\"]\n",
    "    out2 = my_archive_file[\"array_2\"]\n",
    "```\n",
    "```python\n",
    ">>> out0\n",
    "array([1, 2, 3])\n",
    ">>> out1\n",
    "array([4, 5, 6])\n",
    ">>> out2\n",
    "array([7, 8, 9])\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Links to Official Documentation\n",
    "\n",
    "- [The 'pathlib' module](https://docs.python.org/3/library/pathlib.html)\n",
    "- [The 'open' function](https://docs.python.org/3/library/functions.html#open)\n",
    "- [Official tutorial: reading and writing files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
